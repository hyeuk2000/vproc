<html>
<head>
<meta name="keywords" content="Simon Southwell, Virtual Processor, VProc, cosimulation, co-simulation, simulation, HDL, verilog, software, hardware, 
ASIC, FPGA, VCS, NC-Verilog, Seamless, C, programming, CPU, processor, embedded, ARM, MIPS, verification, test">
<title>Virtual Processor</title>
</head>
<body style="font-family:Arial; font-size:11pt" vlink="#0000ff" alink="#0000ff" link="#0000ff" background="images/bkgnd.jpg">

<center>
<h1>Virtual Processor (VProc)</h1>
<font face="Arial" size="2">by
Simon Southwell
<BR>
19th June 2010 </font>
<BR>
&nbsp;
</center>
<hr>
<center>
<h2>abstract</h2>
</center>
<p style="font-size:10pt">
A co-simulation element is presented which abstracts away the communication between 
a user C interface and a verilog task based interface, wrapped in a simple
behavioural HDL module, over the PLI of a simulator, 
as a building block for a processing element, whose code is a normal C program
written and compiled for the host computer, controlling bus type operations in the
verilog simulation environment. This 'virtual processor' (VProc) element has a basic
memory type interface in the verilog domain, and a simple API in the C domain, allowing
read and write operations and support for simple interrupts. The interfaces are
kept as simple as possible, but descibed is the means to build, on top of this
fundamental co-simulation element, any arbitrary complexity of bus interface
(e.g. AHB or PCI-Express) which can then be controlled by a user written program,
compiled for the host computer.
</p>
<p>&nbsp;</p>
<hr>

<h2>Contents</h2>
<ul style="font-size:10pt">
<li><a href="#Intro">Introduction</a>
<li><a href="#VerilogBusStructure">Verilog Bus Structure</a>
  <ul>
  <li><a href="#PliSyntax">PLI Syntax</a>
  </ul>
<li><a href="#WritingUserCode">Writing User Code</a>
  <ul>
  <li><a href="#InOut">Input and Output</a>
  <li><a href="#AdvTim">Advancing Time</a>
  <li><a href="#Int">Interrupts</a>
  <li><a href="#UserCB">User Callback</a>
  <li><a href="#LogMess">Log File Messages</a>
  </ul>
<li><a href="#AddingC">Adding C Functions to Simulator</a>
  <ul>
  <li><a href="#VCS">VCS</a>
  <li><a href="#NcVerilog">NC-Verilog</a>
  <li><a href="#ModelSim">ModelSim</a>
  </ul>
<li><a href="#DelivFiles">Delivered Files</a>
  <ul>
  <li><a href="#Download">VProc Download</a>
  </ul>
<li><a href="#MessPass">Message Passing</a>
<li><a href="#Limits">Limitations of VProc</a>
<li><a href="#BuildComplex">Building more complex Virtual Processors</a>
  <ul>
  <li><a href="#AHB">An AHB processing element</a>
  <li><a href="#PCIE">PCI Express Host Model</a>
  </ul>
<li><a href="#Enhancements">Pending Enhancements</a>
<li><a href="#conclusions">Conclusions</a>
</ul>

<a name="Intro"></a>
<h2>Introduction</h2>
<p>
The concept of a virtual processor is far from new, as is the concept of 
hardware/software co-simulation. Tools such as V-CPU from Summit or 
Seamless from Mentor Graphics, give a professional way of running software 
targetted for a processor or system under development early in the design cycle. 
Although these tools are mainly aimed at running specifically targetted 
processors (ARM, Mips, etc.), some have the ability to run in 'host' mode (such 
as V-CPU), as a true 'virtual processor'.
</p><p>
In this context, a virtual processor is a means to run host compiled programs 
as normal programs in the OS environment, with all its facilities available, 
which are the control source for a bus of an associated instantiated HDL 
module in a simulation environment running on the same machine. This has 
the advantage of not relying on cross-compilers in order to introduce a 
processing element in a simulation; either to act as a test harness stimulus, or 
to replace an, as yet, non-existing embedded processor. With the software on 
the virtual processor written in C or C++ (or with suitable C style linkage)
and a suitable I/O access API layer, 
early development of code in this environment feeds forward directly to the 
actual target processor with minimal changes.
</p><p>
The 'VProc' package is a thin <em>'veneer'</em> to enable the development of a 'host' 
virtual processor system and provide a basic co-simulation environment. 
It isn't necessarily meant to be an end in itself, but hides the 
co-simulation communication complexities for easily and quickly constructing
a virtual processor environment, with the bus functional capabilities
desired.  Enough has been done to set up a link between one or more virtual 
processors and user written programs, compiled into the simulation 
executable. A very basic API is provided to the user code to allow control of 
the HDL environment. What's not provided in VProc is the actual bus functional 
models (BFMs) for specific protocols and their corresponding API software 
layers. This is left for the developer. But this also means that any arbitrary 
protocols can be supported, including proprietry ones. Enough functionality is 
provided at the C/HDL boundary to support (it is believed) any arbitrary 
protocol that one may conceive. 
</p><p>
Where the boundary is chosen between
functionality in C and BFM support in verilog is not restricted by
this model. At one extreme, the pins of a verilog module can be
mapped directly in to the VProc address space and the user C code controls
the pins directly each cycle. At the other extreme, a complex verilog
model for a given bus has, say, control registers mapped into the VProc,
which simply reads and writes them to affect complex bus behaviour. The
choice is left to the implementer, and maybe affected by what's already
available in terms of source code and HDL models, as much as by the
preference of the designer, or speed requirements of the model. 

For example, a PCIe model might simply have its 10 bit wide, pre-serialised,
lanes directly addressable by the virtual processor. 
Only serialisation is left to do in Verilog (if required)&mdash;all the rest
of the PCIe protocol could be handled by the user program associated
with the VProc. On the other hand, 
a Virtual AMBA Bus Processor used in a
test harness might
utilse an already existing HDL interface block to connect to a transactional bus model
which was then controlled by mapping much simpler input signals into VProc.
</p>
<br>
<center>
<img style="box-shadow: 10px 10px 15px #d0d0d0"; src="images/VProcDiag.gif">
</center>
<br>
<p>
The above diagram shows what a typical virtual processor system set of 
layers might be. The bottom layers are provided with this system. On top of 
that a BFM in the HDL domain and an equivalent Bus API in the C domain are 
constructed to initiate bus transactions for the given targetted protocol. This 
system can then be used to run a user program which communicates with the 
target simulation.
</p><p>
Currently with this system up to 64 virtual processors may be instantiated in a 
single simulation. The link between the user programs and the simulator is 
implemented as messages passed via semaphore protected shared memory. 
The interface between the HDL domain and the C environment is via the 
standard verilog PLI interface, restricting it to Verilog (as opposed to VHDL). It 
could just as easily have been via VCS's DirectC, or some other method 
provided by the simulator (e.g. direct instantiation in SystemVerilog).
</p><p>
Each verilog module has access to two main 'tasks' in C (still within the 
simulation's process). <tt>$vinit</tt> is used to initialise a node specific message 
area and initiate communication with user code for that node in a new thread. 
Each VProc module calls <tt>$vinit</tt> once at time 0, passing in a node number. 
</p><p>
Communication between the Verilog module and the user code is done using 
calls to <tt>$vsched</tt>. The bus status is sent with the node number, and routed to 
the relevant user thread's message area and a semaphore set. The 
simulation code then waits for a return semaphore. The user code, waiting for 
a simulation message, responds with a message in the other direction, with a 
node number and a new bus state plus a tick count, clearing the incoming 
semaphore and setting its outgoing semaphore. Verilog state is updated via 
the PLI, and the module waits for the number of ticks to have passed, or an 
IO transaction is acknowledged, before calling $vsched again. 
</p>
<center>
<img src="images/VProcDiag2.png">
</center>
<a name="VerilogBusStructure"></a>
<h2>Verilog Bus Structure</h2>
<p>
In the bundled VProc package (see <a href="#Download">download</a> section) a simple
memory bus module is provided to illustrate the use of the VProc elements. This
can be used as the starting point for connection to a BFM, but the VProc verilog
tasks can be used seperately in a user defined module wrapper if desired.
The verilog code is <tt>f_VProc.v</tt> in the top level VProc directory, with the software source
in <tt>code/</tt>.
</p>

<p>
The bus interface of the provided verilog VProc module is kept as simple as possible. 
Any complexity required for a particular protocol must be added as a wrapper 
around this simple interface, or a new wrapper created.
The IO consists of a data write and data read bus. The width of the data 
busses is 32 bits. A 32 bit address is provided for the read and write 
accesses, with associated write and read strobes (<tt>WE</tt> and <tt>RD</tt>). 
Acknowledgement inputs for the accesses are <tt>WRAck</tt> and <tt>RDAck</tt>, which will 
hold off returning to the user code until active (which could be immediately).
</p>
There is an interrupt input which causes an early call to <tt>$vsched</tt> when 
active. Normally <tt>$vsched</tt> is only called when the tick count has expired, 
(set when the previous $vsched call returned) or when an IO call is acknowledged. An interrupt 
causes <tt>$vsched</tt> to be called, flagging the interrupt as the reason for the call, and 
allowing an interrupt message to be sent to the relevant user thread. The return 
message would not normally update the tick count (though it can), so that the original 
scheduled call still gets invoked.
</p><p>
When a simulation 'finishes' (i.e. <tt>$finish</tt> is called, or the simulation is quit), 
then <tt>$vinit</tt> is effectively called in the background. At this stage, the user 
threads are shut down and the simulation cleanly exited.
</p><p>
The node number is also passed in to uniquely identify each VProc. If two 
nodes have the same node number, then undefined behaviour will result. The 
module definition is shown below:
</p>
<pre style="font-family:Courier; font-size:11pt; color:#603000";>
    module VProc (Clk, Addr, WE, RD, DataOut, DataIn, 
                  WRAck, RDAck, Interrupt, Update, UpdateResponse, Node);

    input         Clk, RDAck, WRAck, UpdateResponse;
    input  [2:0]  Node, Interrupt;
    input  [31:0] DataIn;
    output [31:0] Addr;
    output [31:0] DataOut;
    output        WE, RD, Update;
</pre>
<p>
The Update output port is a special signal which allows multiple reads and 
writes within a single delta cycle; useful when trying to construct or read 
vectors wider than 32 bits. The port changes state (1 to 0 or 0 to 1) whenever 
the outputs change. By waiting on this event, and updating local register 
values each time it transistions, large vectors may be processed in a single delta cycle. For 
example, suppose the VProc module is instantiated with a wire '<tt>Update</tt>' on 
the port, then an '<tt>always @(Update)</tt>' can be used to instigate a decode of 
the new address and strobes and update or return sub-words of a large 
vector. Control of whether multiple <tt>Update</tt> events occur in a single delta 
cycle is affected by a parameter into the access C procedures (see 
<a href="#WritingUserCode">Writing User Code</a>
below). The Update signal needs a response to flag that the Updating is
complete, via the <tt>UpdateResponse</tt> input. This would normally be an external
register that is, like <tt>Update</tt>, toggled 1 to 0 or 0 to 1, at the end of the 
update&mdash;say at the end of the <tt>Update</tt> always block. 
It is not necessary to use the <tt>Update</tt> event signal if delta time 
access of wide vectors is unnecessary. A normal inspection of the strobes on 
an '<ttr>always @(posedge Clk)</tt>' (say) will work just fine, but then <tt>VWrite()</tt> 
and <tt>VRead()</tt> must never be called with <tt>Delta</tt> set to 1 (see below for details of this)).
If delta updating is not required, then the <tt>UpdateResponse</tt> input should be directly 
connected to the <tt>Update</tt> output as the VProc module will suspend until the response 
comes back.

</p>
<a name="PliSyntax"></a>
<h3>PLI syntax</h3>
<p>
The actual syntax of the PLI task calls are not important if using
the provided memory bus BFM (see <a href="#VerilogBusStructure">above</a>), as this is taken care of by the verilog in the VProc module. So
this section can be skipped if the memory bus BFM is to be used unmodified,
but if wishing to create one's own wrapper module, then the PLI tasks of VProc are as follows:

<pre style="font-family:Courier; font-size:11pt; color:#603000";>
   $vinit     (NodeIn)
   $vsched    (NodeIn, InterruptIn, DataIn, DataOut, AddrOut, RWOut, TicksOut)
   $vprocuser (NodeIn, ValueIn)
</pre>

All the arguments to the PLI tasks are verilog <tt>integer</tt> type, for simplicity
of interfacing to C. Vectors of verilog signals can still be passed in (including
padding with 0's), but care must be taken as an x or z on even a single bit causes
the whole returned value to be 0. This can be hard to debug, and so checks should be
made in the verilog code.
</p>
The <tt>$vinit</tt> task is usually called within an <tt>initial</tt> block. The 
<tt>Node</tt> input needs to be a unique number for the VProc instantiated. If called
with a constant or a module parameter, then this can be at time 0 within the initial block. 
If it is connected to a port or wire, even if ultimately connected to a constant, then
a small delay must be introduced before callin <tt>$vinit</tt>, as the call to the PLI
function and the wire assignment ordering is indeterminate.
</p>
<p>
The main active task call is to <tt>$vsched</tt>. It is this call that delivers
commands and data, and has new input returned. It too has a node input and, in addition,
an interrupt and data input. The interrupt is an integer value, but the valid range is
from 0 (no interrupts) to 7. The data input is a single 32 bit value. <tt>$vsched</tt>
is called for every input update required, or expired tick. On return, updated DataOut
and AddrOut values are returned, along with a directional RWOut. These map easily to the memory
style interface of the VProc module, but can be interpreted in any way. E.g. AddrOut is
a pin number, the DataOut value is the pin value (including x or z, say), and the RWOut
determines whether the pin value is just read, or both read and updated.
</p>
<p>
The <tt>TicksOut</tt> output is crucial to the timing of the <tt>$vsched</tt> calls.
In normal usage this should update a timer counter, which then ticks down until 0,
when <tt>$vsched</tt> is called once more. So usually a value equal or greater than zero is
expected. For a usage where communication is required every cycle, then this would
be zero (i.e. no additional cycles), but it can be an enormous value 
(up to 2^31 - 1) if the software wishes to go to sleep.
If <tt>$vsched</tt> was called on an interrupt, then a new value of TickOut is
returned, where a value greater than zero can be used to override the current tick count,
or leave alone if 0. This allows a sleeping VProc to wake up on interrupt. A value
of less than 0 can be returned (for non-interrupt calls), indicating that the call is for a "delta cycle"
update, and another call is expected before advancing time in the simulation. This
allows multiple commands/updates to affect state before advancing the clock. Only
when a TickOut value of 0 or more is returned should the code cease calling 
<tt>$vsched</tt> and processing the commands.
</p>
<p>
The <tt>$vprocuser</tt> syntax is a straight forward set of a node number
and single integer value. The value is not interpreted and is passed straight
on to the registered user function (if one exists).
</p>
<p>
For those interested in following this up further with an example usage, then look at 
the <tt>f_VProc.v</tt> verilog and <tt>Pli.tab</tt> (or <tt>VSched_pli.c</tt>) code provided 
for the memory interface BFM.
Only the PLI 1.0 task/function (TF) routines are used in the virtual processor to 
simplify and speed up the interface. I.e. all communications between C and verilog are 
only via the arguments to the PLI tasks.
</p>
<p>
Of course, the PLI tasks are only one side of the interface, and they are connected
indirectly to C API functions. These are described in the <a href=#WritingUserCode>next section</a>.
</p>

<a name="WritingUserCode"></a>
<h2>Writing User Code</h2>
<p>
The user code that's 'run' on a virtual processor has an entry point to a 
function whose prototype is as follows:
</p>
<pre stylYe="font-family:Courier; font-size:11pt; color:#603000";>
    void VUserMain<em>N</em>(void);
</pre>
<p>
The <em>N</em> indicates the node number of the virtual processor the
user code is run on. At start up, the initialisation code in the API
will attempt to call a user function of this form. So, for instance,
if there is instantiated a VProc with node number 8, VUserMain8()
is called. There must be one such function for each instantiated
VProc, otherwise a runtime error is produced, and, of course, each
instantiated node must have a different node number from all the rest.
</p><p>
When in a VuserMain<em>N</em>() function, the user code thus has access to some 
functions for communication to and from the VProc bus in the simulation, 
which appear as if defined as below:

<pre style="font-family:Courier; font-size:11pt; color:#603000";>
    int  VWrite        (unsigned int addr, unsigned int  data, int delta, int node);
    int  VRead         (unsigned int addr, unsigned int *data, int delta, int node);
    int  VTick         (unsigned int cycles, int node);
    void VRegInterrupt (int level, pVUserInt_t func, int node);
    void VRegUser      (pVUserCB_t func, int node);
    void VPrint        (char *format, ...);
</pre>
<p>
In order to access these functions, <tt>VUser.h</tt> must be included at the head of 
the user code file. 
</p>
<a name="InOut"></a>
<h3>Input and Output</h3>
<p>
If the user code needs to write to the VProc's bus, then 
<tt>VWrite()</tt> is called with data and address. The function will return after the 
simulation has advanced some cycles depending when the write acknowledge 
is returned in the VP module input and a status is returned. The status is 
actually the <tt>DataIn</tt> value on the <tt>$vcsched</tt> parameters, and so is 
implementation dependant, depending on the address decoding 
arrangements outside of VProc. The Delta flag can override the advance of 
simulation time or the waiting on an acknowledgement and performs the write 
in the current simulation delta time. This can be employed when it is required 
to write to a number of separate registers to form, say, a wide, bus specific, 
transaction which may need to be issued once per clock cycle. Setting <tt>Delta</tt> 
to 1 for all the writes except the last one allows words greater than 32 bits to 
be constructed in a single cycle. Care must be taken that <tt>VWrite()</tt> (or 
<tt>VRead()</tt> for that matter) is not always called with <tt>Delta</tt> set to 1, as this may 
result in registers being overwritten without simulation time being advanced. It 
is also necessary to have support for this feature in the verilog wrapper 
around VProc, using the 'delta' event to instigate external register accesses 
instead of the more normal clock edge 
(see <a href="#VerilogBusStructure">Verilog Bus Structure</a> above).
</p><p>
Similarly a read is invoked with <tt>VRead()</tt>, which returns an arbitrary number 
of cycles later since the simulation is waiting on a read acknowledge. The 32 
bit read value is returned into the variable pointed to by the second argument. 
A <tt>Delta</tt> input acts in the same way as writes, allowing wide data reads 
without advancing simulation time, or waiting on an acknowledge.
</p>
<a name="AdvTim"></a>
<h3>Advancing Time</h3>
<p>
If the user code isn't expecting to need to process any IO data for some time, 
it can effectively go to sleep for a number of clock ticks by calling <tt>VTick()</tt>, 
passing in a cycle count. This should be used liberally to allow the simulator to 
advance time without the need for heavy message traffic polling on a register 
status (say). Interrupts can be used to flag events and wake up the main 
process if the wait time is arbitrary or indeterminate (see below).
</p>
<a name="Int"></a>
<h3>Interrupts</h3>
<p>
There are (currently) seven levels of interrupt. For every cycle that a VProc's 
<tt>Interrupt</tt> input is non-zero, a call is made to a previously registered function.  
To register a function <tt>VRegInterrupt()</tt> is call with the interrupt level (1 to 
7) and a pointer to a function. The function pointer must be of type 
<tt>pVUserInt_t</tt> (i.e. a pointer to a function returning an <tt>int</tt>, with <tt>void</tt> argument 
list). The user interrupt function must return an integer, which is normally 0, 
but may be > 0 if the interrupt function decides it wants to override the 
schedule count of the outstanding IO or Tick call. A runtime error is generated 
if the interrupt level is one which has no registered interrupt function.
</p><p>
In this release, the Interrupt routines cannot make calls to the IO routines (as 
this will break the scheduling). They are intended only to flag events, which, if 
IO status is required, the main routine can service. It should still possible to 
emulate full interrupt service routines, even with this limitation. For example, if 
the <tt>VRead()</tt> or <tt>VWrite()</tt> calls are wrapped inside another procedure, 
interrupt event status can be inspected each time they return, and a call to a 
handler made if required, based on status updated by a call to the inetrrupt 
handler. This handler would now be part of the main thread, and can safely 
make IO accesses. This implies that simulation IO calls are atomic, and won't 
be interrupted (unless the interrupt function changes the pending tick count, 
which affectively cancels the IO, which would need re-issuing). By adding this 
slight complication in the user code, the VProc implementation becomes 
much simpler. 
</p>
<a name="UserCB"></a>
<h3>User Callback</h3>
<p>
As well as registering interrupt callback functions, a general purpose callback
function may be registered using <tt>VRegUser()</tt>. It is similar to <tt>VRegInterrupt()</tt>,
but requires no 'level' argument. Registering a function in this manner does
not automatically attach it to an event, but instead attaches it to a
defined verilog task '<tt>$vprocuser(node, val)</tt>'. To invoke the registered function
$vprocuser is called with the node number corresponding to the VProc 
instantiation running the user code. A value is also specified and is
passed in as an integer argument to the user function. This could be used
to select between different functions, depending from where the 
task is called.  Example uses might be to call the function at regular intervals 
to dump debug state, or to call when about to finish to do some tidying up in the 
user code etc. It should be noted that the registered function is synchronous to 
the simulator thread, and <em>not</em> the user thread. Therefore, if the function 
is to communicate with the main user thread it must do so in a thread safe manner.
</p><p>
The registered user function must be of type <tt>pVUserCB_t</tt>, which is to say
a function returning void, with a single integer argument. E.g.:
</p>
<pre style="font-family:Courier; font-size:11pt; color:#603000";>
    void VUserCB (int value);
</pre>
<p>
If <tt>$vprocuser</tt> is invoked for a given node before a callback function has been 
registered, then no effect is seen and the task exits. It is therefore safe 
to invoke the task even if the user code never registers a function. However,
it is not safe to invoke the task for a non-existent node, and undefined
behaviour will result.
</p>
<a name="LogMess"></a>
<h3>Log File Messages</h3>
<p>
The <tt>VPrint()</tt> function (actually a macro) allows normal <tt>printf</tt> type formatted
output, but sends to the simulation log output (and thus to any log file
being generated) instead of <tt>stdout</tt>. This makes correlation between verilog
log data and user code messages much easier, as they are sent to the same
output stream, and appear in the correct relative order.
</p>

<a name="AddingC"></a>
<h2>Adding C functions to Simulators</h2>

<a name="VCS"></a>
<h3>VCS</h3>
<p>
The internal C functions called by the VProc modules' invocation of <tt>$vinit</tt> 
and <tt>$vsched</tt> (<tt>VInit()</tt>, <tt>VSched()</tt> and <tt>VHalt()</tt>) are compiled into the 
verilog during normal simulation compilation, along with all the user code and 
any BFM support code 
Simply add references to the list of <tt>.c</tt> files somewhere in the 
vcs compile command. When compiling <tt>VSched.c</tt> for VCS, then 'VCS' must be defined, 
which will usually be the case if compiled directly from the VCS command line. 
If compiling to an object first, the use <tt>-DVCS</tt>. This contains the PLI code as 
well, which the simulator must be informed about with a PLI table file (<tt>Pli.tab</tt> 
provided), and indicated in the command line with the <tt>-P</tt> option. E.g.:
</p>
<pre style="font-family:Courier; font-size:11pt; color:#603000";>
    vcs <normal compile options> *.c -P Pli.tab -Xstrict=0x01 
</pre>
<p>
Needless to say, the user code, <tt>VSched.c</tt> and <tt>Pli.tab</tt> files need to be in 
the compilation directory, or the above modified to reference the files 
remotely. The <tt>-Xstrict=0x01</tt> is a VCS requirement for using threads in PLI code,
and the <tt>pthread</tt> and <tt>rt</tt> libraries must be compiled in (e.g. use the <tt>-syslib</tt> option).
</p>
<a name="NcVerilog"></a>
<h3>NC-Verilog</h3>
<p>
Adding C functions to NC-Verilog is slightly different to VCS. Firstly the PLI 
code must be compiled as a shared object. In our case, this includes all the 
user code as well, compiled into a file <tt>VSched.so</tt> (e.g. use <tt>-fpic -shared</tt> 
options with <tt>gcc</tt>). The PLI table, unlike for VCS, is compiled in as an 
array, so no extra table file is required. To access this code the 
<tt>+ncloadpli1</tt> command line option is used at compile time. E.g.
</p>
<pre style="font-family:Courier; font-size:11pt; color:#603000";>
    ncverilog &lt;normal compile options&gt; +ncloadpli1=VSched:bootstrap
</pre>
<p>
The pthread and rt libraries must also be linked with the shared object.
</p>

<a name="ModelSim"></a>
<h3>ModelSim</h3>
<p>
ModelSim compiles the verilog, and runs the simulation seperately, with the commands 
<tt>vlog</tt> and <tt>vsim</tt> respectively. The PLI code is reference at the running
of the simulation. So, assumning the PLI C code was compiled as <tt>VProc.so</tt>, the
<tt>vsim</tt> command is structed as shown below:
</p>
<pre>
    vsim &lt;normal compile options&gt; -pli VProc.so
</pre>

<p>
As with NC-Verilog, the pthread and rt libraries must be linked with the shared object.
</p>

<a name="DelivFiles"></a>
<h2>Delivered Files</h2>
<p>
In order to use the virtual processor, the following files are used.
</p>
<table style="font-size:10pt">
<tr> <td>&nbsp;</td> <td style="font-family:courier">f_VProc.v</td>         <td>:</td>      <td>Virtual processor verilog</td></tr>
<tr> <td>&nbsp;</td> <td style="font-family:courier">VSched.c</td>          <td>:</td>      <td>Simulation (server) side  C code</td></tr>
<tr> <td>&nbsp;</td> <td style="font-family:courier">VSched_pli.h</td>      <td>:</td>      <td>Common PLI definitions and prototypes</td></tr>
<tr> <td>&nbsp;</td> <td style="font-family:courier">veriuser.c</td>        <td>:</td>      <td>PLI table (NC-Verilog)</td></tr>
<tr> <td>&nbsp;</td> <td style="font-family:courier">Pli.tab</td>           <td>:</td>      <td>PLI table (VCS only)</td></tr>
<tr> <td>&nbsp;</td> <td style="font-family:courier">VProc.h</td>           <td>:</td>      <td>VProc layer definitions</td></tr>
<tr> <td>&nbsp;</td> <td style="font-family:courier">VUser.c</td>           <td>:</td>      <td>User (client) side C code</td></tr>
<tr> <td>&nbsp;</td> <td style="font-family:courier">VUser.h</td>           <td>:</td>      <td>User (client) side header file</td></tr>
<tr> <td>&nbsp;</td> <td style="font-family:courier">VUserMainT.c</td>      <td>:</td>      <td>Template for user code</td></tr>
</table>

<p>
Note: If using NC-Verilog, the compiled shared object, <tt>VSched.so</tt>, must be available in the invocation 
directory. 
</p>
<p>
VProc is released under the GNU General Public License (version 3). See <tt>LICENSE.txt</tt> in the
downloadable package for details (see <a href="#Download">VProc Download</a> section to access
package).
</p>
<p>
Along with the above files are delivered example makefiles for compiling the C and verilog.
These have been tested in a specific environment and are for reference only. Adaptations will
need to be made to the local host environment, and no guarantees are given on their
validity. A simple test example is also bundled, with a basic random memory access from
one VProc, and an interrupt generation from another. Again, as for the makefiles, this
is for reference only.
</p>

<a name="Download"></a>
<h3>VProc Download</h3>

The VProc package can be downloaded from <a href="https://github.com/wyvernSemi/vproc">github</a>. This contains
all the files needed to use VProc, along with <em>example</em> makefiles, scripts
and test bench. Note that the only recent testing has been done with ModelSim on Linux.

<h1>Appendices</h1>

<a name="MessPass"></a>
<h2>Message Passing</h2>
<p>
The figure below shows a typical exchange of messages between the HDL 
simulation and one of the user threads. There can, of course, be multiple user 
threads (one for each VProc) with similar interactions with the simulator. 
</p>
<center>
<img style="box-shadow: 10px 10px 15px #d0d0d0"; src="images/MessageDiag.gif">
</center>
<br>
<p>
As can be seen, there are normally two types of messages exchanged 
between user thread and simulation. The simulation, at time 0, always sends 
the first message. The simulation message to the user thread (a 'receive' 
message) includes the value of the <tt>DataIn</tt> port value, as well as an interrupt 
status flag. Once <tt>$vsched</tt> is called and a receive message sent, the 
simulation is effectively paused. Running in VUserMain<em>N</em>(), the simulation will 
not advance until <tt>VWrite()</tt>, <tt>VRead()</tt> or <tt>VTick()</tt> is invoked. Any amount 
of processing can occur in the user process before this happens, but it 
effectively happens in zero (delta) time as far as the simulation is concerned. 
When, say, a <tt>VWrite()</tt> is eventually called a 'send' message is sent back 
to the simulation with update data. In addition a Tick value is returned which is 
usually 0, meaning that the simulation will not call <tt>$vsched</tt> again until the 
write (or read) has been acknowledged externally. However it can be -1, in 
which case <tt>$vsched</tt> is called again after the update without waiting for an 
acknowledge, or waiting for the next clock edge. This allows a delta time 
update, enabling vectors wider than 32 bits be written (or read) before 
allowing the simulation to act upon the updated data. This is shown in the 
second exchange in the above figure. Simulation time can also be advanced 
without the need to perform a read or a write. Calling <tt>VTick()</tt> from the user 
process sends a message with a positive value for the Ticks. This simply 
delays the recalling of <tt>$vsched</tt> by the number of cycles specified. Effectively 
the user process can go to sleep for a set number of cycles; useful if waiting 
for an event that is known to take a minumum, but significant, time.
</p><p>
The send and receive messages are always paired like the exchanges in the 
above figure&mdash;one never sees two or more consecutive messages in the 
same direction. This gives full synchronisation between the simulation 
process and the user thread, and is controlled with send and receive 
semaphores&mdash;a pair for each VProc instantiated. If an interrupt occurs, a 
receive message is still delivered (see figure), but potentially earlier than 
expected. This will send the interrupt level in the message, and the 
appropriate registered function is called. When the function returns, a new 
send message is sent back, but the update values are ignored. Only the tick 
value is of significance. Normally a tick value of 0 is sent back. In this case the 
original state for the outstanding access is retained, and so the expected 
receive message for the original <tt>VRead</tt>/<tt>VWrite</tt> is still generated, when it 
would have been, if there had been no interrupt. A tick value greater than zero can be 
returned by the interrupt function, in which case the current outstanding tick 
count can be overridden, and the next receive message invoked earlier or 
later than originally set. This is useful for cancelling or extending a VTick() 
call. Say one has set off some action in the simulation which must complete 
before the user code can continue, but it is of abitrary length in time. By 
calling <tt>VTick()</tt> with a very large number, and by arranging the external verilog 
to invoke an interrupt when the action is completed, the interrupt routine 
called can clear the tick count to zero, and the user code will fall through the 
<tt>VTick()</tt> at just the right time, without, for example, the need to continually poll 
a register status, generating large amounts of message traffic and slowing the 
simulation down.
</p>

<a name="BuildComplex"></a>
<h2>Building more complex Virtual Processors</h2>
<p>
The VProc, as presented above, presents a simple environment, which has
a memory style interface in the verilog domain, and a very simple read/write
style API for the user C program to use, with simple support for interrupt
handling. This would have limited scope as a useful verification tool
if that was the limit of its capabilities. The main purpose of VProc is
to hide away the verilog/C interface complexities, and allow a user
to have an environment where a more useful and realistic virtual processor
may be built. As such, two scenarios are described below, where VProc could be
used to create more practical test elements.
</p>

<a name="AHB"></a>
<h3>An AHB processing element (ARM substitute).</h3>
<p>
Suppose a test environment for an ARM based chip is created which is using 
an ARM model or netlist in the simulation. The test code for the processor
needs to be cross-compiled to target the ARM, with the limitations on
embedded ROM and RAM, and the compilation setup for the different areas
of memory etc. relevant to the processor in the simulation. It may be that
for greater than 80% of the tests it is not important that the code is 
running exactly as would be on the silicon implementation of the processor,
but only bus transactions, on the AHB bus from the processor, are valid
to configure the chip, instigate operations, monitor status, and log information
to the simulation log. VProc can be the base to replace the ARM model in
these situations, giving additional facilities of computation (all host
libraries are available), checking, logging etc., that aren't possible
in the actual processor model.
</p>
<p>
In order to do this VProc needs to be wrapped in some code to turn its
memory based interface into an AHB interface, and the C API extended
to wrap up the basic VProc API. In this example, let's assume that there
is available a bus functional model (BFM) in behavioural verilog for
AHB. This BFM, say, is controlled by reading and writing  internal
registers via a memory mapped interface. In that case, it is a simple
matter to connect VProc's memory style interface to the register interface 
of the BFM, and wrap the whole in another module to hide away the details.
</p>
<p>
Controlling the BFM from C code is now simply a matter of sequences of
read and write calls over the VProc API to configure the registers and
instigate bus traffic. It is likely that for any given bus type transaction
multiple register accesses are likley, so the normal thing to do would be
to extend the VProc API with fundamental AHB bus API operations, such that
all supported BFM transactions are a single C function call. This new AHB
API is then the interface for verification tests to be written.
</p>
<p>
As an aside, one could imagine that if an instruction set simulator (ISS)
existed for the processor being modelled (in this case an ARM processor),
then this could be interfaced to the API described above to provide
a full instruction capable model for verilog simulation. In this ARM scenario,
this defeats the object of replacing the original ARM model, but suppose 
a new processing element or microcode engine is being designed, and 
an ISS is available long before the RTL design is ready and verified,
then this could allow early testing of the rest of the RTL, and even
as a platform for embedded firmware test and development.
</p>

<a name="PCIE"></a>
<h3>PCI Express Host Model</h3>
<p>
This scenario is for a model to drive a PCI Express (PCIe) interface. The
PCIe interface on the chip under test is the element that is under verification,
and needs a transactor to drive it. In this scenario, let's assume, unlike for 
the AHB model, that there is no existing BFM model in verilog. Whatever code drives
the bus (actually link in the case of PCIe) must be written from scratch. We 
want to use VProc to allow a C program to deliver transactions over the bus,
and receive and process returned data etc. 
</p>
<p>
Because there is no BFM, and we are going to have to write a C API for the
PCIe transactions anyway, let's decide that an absolute minimum of verilog
is going to be written, and that we will model almost everything in C. Thus
the verilog will consist only of mapping each of the PCIe lanes (the serial
input and output ports) in to locations in the VProc memory map. In this case
each lane will be a 10 bit value, with a behavioural serialiser/deserialiser
in verilog. Thus lane 0 is mapped at address 0, lane 1 at address 1 etc. To
update all lanes (anything from 1 to 32 can be used at once), delta updates
to write to all the lanes (bar the last, to increment the clock) are done,
returning the read value for the said lane on return. In this scenario,
a single cycle always elapses for each lane set update, and the lanes
are updated every cycle.
</p>
<p>
This is about as fundamental a C to verilog mapping that is possible with 
VProc. Each IO pin is simply mapped to memory and update/sampled for
every clock. The C API then has to extend the basic VProc API in to
all the PCIe transaction types. This is a much more complex task than 
for the AHB scenario above, but is made here simply because this
functionality must be coded somewhere (there is no BFM, remember), and
so C was the choice made. The C code would need to provide some basic conversions
for the PCIe standard, such as 8/10 encoding/decoding, inline data pattern
generation such as ordered sets, data link transactions like flow control
and the data transactions such as memory, IO and configure reads and writes.
A transmit queueing system is required, and the ability to handle split completions
etc. This code should be written to hide these details and present an extended
API to a user which allows single call access to the bus for every type
of transaction. As you may appreciate by now, this is a non-trivial task,
and VProc does not, of itself, solve these problems&mdash;it just enables
the ability to do this. Under different circumstances it might be better to place more
functionality in verilog behavioural code, and simplify the C code. It will depend 
on local circumstances.
</p>

<a name="Limits"></a>
<h2>Limitations of VProc</h2>
<p>
There are few limitations to the model, which compiles and runs on a variety
of simulators (4 have been tested), and platforms (Linux, Solaris). There is
one flaw however, regarding the use of save and restore (or checkpointing, as it
is sometimes known). Although support for checkpointing has been implemented
in the model, inconsistent results are acheived&mdash;some simulation runs have
worked, others behave differently, even by simply saving a checkpoint, and
not just after a restart. Currently there is no fix for this in the published
version of VProc, and the use of checkpointing is not yet supported.
</p>

<a name="Enhancements"></a>
<h2>Pending Enhancements</h2>
<p>
<ul>
<li> Transfer of data <em>blocks</em> over API
<li> Common entry point for all nodes (VUserMain()), to allow common code on all nodes.
<li> Fix checkpointing
<li> Pointer memory accesses (i.e. not read/write functional calls, but pointer references)
</ul>
</p>

<a name="conclusions"></a>
<h2>Conclusions</h2>
<p>
A fundamental co-simulation element, VProc, has been described which virtualises away
the C and simulation interface to give a basic processing element, controllable
by host compiled code. This basic element provides enough functionality such that
any arbitrary processing element with a given bus can be constructed, and two
scenarios given (AHB and PCIe) with two very different approaches, showing
the ultimate flexibility of the VProc element. The VProc code is available for
<a href="#Download">download</a> and is released under the GNU GPL version 3.
This code, it is hoped, will allow engineers to construct highly flexible test 
elements, where none already exists, with the bus functionality they require
combined with the power and flexibility of a full host programming environment.
The two bus scenarios described were based on real examples using VProc, but it is
hoped that VProc will be used in even more ways than this or originally envisaged.
</p>

<hr>
<address>
Copyright &copy; 2002-2010 Simon Southwell<br>
<a href="mailto:simon&#64anita-simulators.org.uk">simon&#64anita-simulators.org.uk</A>
</address>
<br><br>
<a href="../wyvernsemi/index.html">Return to homepage.</a>
</body>
</html>

